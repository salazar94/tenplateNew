{"version":3,"sources":["./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm2015/ng-zorro-antd-affix.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAmC;AAC4B;AACE;AACR;AACmJ;AAC9H;AACnB;AACa;AACV;AACsB;;AAEpF;AACA;AACA;AACA;AACwC;AACY;AACE;AACN;AACJ;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uDAAY;AACxC;AACA,0CAA0C,oDAAkB;AAC5D,kCAAkC,+CAAa;AAC/C,4BAA4B,yCAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,yDAAS;AAChG;AACA;AACA,kCAAkC;AAClC;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,wCAAwC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,2CAAK,kDAAkD,+CAAS,iDAAiD,yDAAS,iBAAiB,mDAAG,UAAU;AACtO,kBAAkB,yDAAS;AAC3B;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qEAAY;AACxB;AACA;AACA;AACA;AACA,kDAAkD,uEAAc;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qEAAY;AACxB;AACA;AACA,gEAAgE,uEAAc;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AA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","file":"default-node_modules_ng-zorro-antd___ivy_ngcc___fesm2015_ng-zorro-antd-affix_js.js","sourcesContent":["import { __decorate } from 'tslib';\nimport { Directionality, BidiModule } from '@angular/cdk/bidi';\nimport { Platform, PlatformModule } from '@angular/cdk/platform';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { EventEmitter, Component, ChangeDetectionStrategy, ViewEncapsulation, ElementRef, Inject, NgZone, Renderer2, ChangeDetectorRef, Optional, ViewChild, Input, Output, NgModule } from '@angular/core';\nimport { Subscription, ReplaySubject, Subject, merge, fromEvent } from 'rxjs';\nimport { takeUntil, map, auditTime } from 'rxjs/operators';\nimport { NzConfigService, WithConfig } from 'ng-zorro-antd/core/config';\nimport { NzScrollService } from 'ng-zorro-antd/core/services';\nimport { shallowEqual, getStyleAsText, InputNumber } from 'ng-zorro-antd/core/util';\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from 'ng-zorro-antd/core/config';\nimport * as ɵngcc2 from 'ng-zorro-antd/core/services';\nimport * as ɵngcc3 from '@angular/cdk/platform';\nimport * as ɵngcc4 from '@angular/cdk/bidi';\n\nconst _c0 = [\"fixedEl\"];\nconst _c1 = [\"*\"];\nvar AffixRespondEvents;\n(function (AffixRespondEvents) {\n    AffixRespondEvents[\"resize\"] = \"resize\";\n    AffixRespondEvents[\"scroll\"] = \"scroll\";\n    AffixRespondEvents[\"touchstart\"] = \"touchstart\";\n    AffixRespondEvents[\"touchmove\"] = \"touchmove\";\n    AffixRespondEvents[\"touchend\"] = \"touchend\";\n    AffixRespondEvents[\"pageshow\"] = \"pageshow\";\n    AffixRespondEvents[\"load\"] = \"LOAD\";\n})(AffixRespondEvents || (AffixRespondEvents = {}));\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nfunction isTargetWindow(target) {\n    return typeof window !== 'undefined' && target === window;\n}\nfunction getTargetRect(target) {\n    return !isTargetWindow(target)\n        ? target.getBoundingClientRect()\n        : {\n            top: 0,\n            left: 0,\n            bottom: 0\n        };\n}\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nconst NZ_CONFIG_MODULE_NAME = 'affix';\nconst NZ_AFFIX_CLS_PREFIX = 'ant-affix';\nconst NZ_AFFIX_DEFAULT_SCROLL_TIME = 20;\nclass NzAffixComponent {\n    constructor(el, doc, nzConfigService, scrollSrv, ngZone, platform, renderer, cdr, directionality) {\n        this.nzConfigService = nzConfigService;\n        this.scrollSrv = scrollSrv;\n        this.ngZone = ngZone;\n        this.platform = platform;\n        this.renderer = renderer;\n        this.cdr = cdr;\n        this.directionality = directionality;\n        this._nzModuleName = NZ_CONFIG_MODULE_NAME;\n        this.nzChange = new EventEmitter();\n        this.dir = 'ltr';\n        this.positionChangeSubscription = Subscription.EMPTY;\n        this.offsetChanged$ = new ReplaySubject(1);\n        this.destroy$ = new Subject();\n        // The wrapper would stay at the original position as a placeholder.\n        this.placeholderNode = el.nativeElement;\n        this.document = doc;\n    }\n    get target() {\n        const el = this.nzTarget;\n        return (typeof el === 'string' ? this.document.querySelector(el) : el) || window;\n    }\n    ngOnInit() {\n        var _a;\n        (_a = this.directionality.change) === null || _a === void 0 ? void 0 : _a.pipe(takeUntil(this.destroy$)).subscribe((direction) => {\n            this.dir = direction;\n            this.registerListeners();\n            this.updatePosition({});\n            this.cdr.detectChanges();\n        });\n        this.dir = this.directionality.value;\n    }\n    ngOnChanges(changes) {\n        const { nzOffsetBottom, nzOffsetTop, nzTarget } = changes;\n        if (nzOffsetBottom || nzOffsetTop) {\n            this.offsetChanged$.next();\n        }\n        if (nzTarget) {\n            this.registerListeners();\n        }\n    }\n    ngAfterViewInit() {\n        this.registerListeners();\n    }\n    ngOnDestroy() {\n        this.removeListeners();\n    }\n    registerListeners() {\n        if (!this.platform.isBrowser) {\n            return;\n        }\n        this.removeListeners();\n        this.positionChangeSubscription = this.ngZone.runOutsideAngular(() => merge(...Object.keys(AffixRespondEvents).map(evName => fromEvent(this.target, evName)), this.offsetChanged$.pipe(takeUntil(this.destroy$), map(() => ({}))))\n            .pipe(auditTime(NZ_AFFIX_DEFAULT_SCROLL_TIME))\n            .subscribe(e => this.updatePosition(e)));\n        this.timeout = setTimeout(() => this.updatePosition({}));\n    }\n    removeListeners() {\n        clearTimeout(this.timeout);\n        this.positionChangeSubscription.unsubscribe();\n        this.destroy$.next();\n        this.destroy$.complete();\n    }\n    getOffset(element, target) {\n        const elemRect = element.getBoundingClientRect();\n        const targetRect = getTargetRect(target);\n        const scrollTop = this.scrollSrv.getScroll(target, true);\n        const scrollLeft = this.scrollSrv.getScroll(target, false);\n        const docElem = this.document.body;\n        const clientTop = docElem.clientTop || 0;\n        const clientLeft = docElem.clientLeft || 0;\n        return {\n            top: elemRect.top - targetRect.top + scrollTop - clientTop,\n            left: elemRect.left - targetRect.left + scrollLeft - clientLeft,\n            width: elemRect.width,\n            height: elemRect.height\n        };\n    }\n    setAffixStyle(e, affixStyle) {\n        const originalAffixStyle = this.affixStyle;\n        const isWindow = this.target === window;\n        if (e.type === 'scroll' && originalAffixStyle && affixStyle && isWindow) {\n            return;\n        }\n        if (shallowEqual(originalAffixStyle, affixStyle)) {\n            return;\n        }\n        const fixed = !!affixStyle;\n        const wrapEl = this.fixedEl.nativeElement;\n        this.renderer.setStyle(wrapEl, 'cssText', getStyleAsText(affixStyle));\n        this.affixStyle = affixStyle;\n        if (fixed) {\n            wrapEl.classList.add(NZ_AFFIX_CLS_PREFIX);\n        }\n        else {\n            wrapEl.classList.remove(NZ_AFFIX_CLS_PREFIX);\n        }\n        this.updateRtlClass();\n        if ((affixStyle && !originalAffixStyle) || (!affixStyle && originalAffixStyle)) {\n            this.nzChange.emit(fixed);\n        }\n    }\n    setPlaceholderStyle(placeholderStyle) {\n        const originalPlaceholderStyle = this.placeholderStyle;\n        if (shallowEqual(placeholderStyle, originalPlaceholderStyle)) {\n            return;\n        }\n        this.renderer.setStyle(this.placeholderNode, 'cssText', getStyleAsText(placeholderStyle));\n        this.placeholderStyle = placeholderStyle;\n    }\n    syncPlaceholderStyle(e) {\n        if (!this.affixStyle) {\n            return;\n        }\n        this.renderer.setStyle(this.placeholderNode, 'cssText', '');\n        this.placeholderStyle = undefined;\n        const styleObj = {\n            width: this.placeholderNode.offsetWidth,\n            height: this.fixedEl.nativeElement.offsetHeight\n        };\n        this.setAffixStyle(e, Object.assign(Object.assign({}, this.affixStyle), styleObj));\n        this.setPlaceholderStyle(styleObj);\n    }\n    updatePosition(e) {\n        if (!this.platform.isBrowser) {\n            return;\n        }\n        const targetNode = this.target;\n        let offsetTop = this.nzOffsetTop;\n        const scrollTop = this.scrollSrv.getScroll(targetNode, true);\n        const elemOffset = this.getOffset(this.placeholderNode, targetNode);\n        const fixedNode = this.fixedEl.nativeElement;\n        const elemSize = {\n            width: fixedNode.offsetWidth,\n            height: fixedNode.offsetHeight\n        };\n        const offsetMode = {\n            top: false,\n            bottom: false\n        };\n        // Default to `offsetTop=0`.\n        if (typeof offsetTop !== 'number' && typeof this.nzOffsetBottom !== 'number') {\n            offsetMode.top = true;\n            offsetTop = 0;\n        }\n        else {\n            offsetMode.top = typeof offsetTop === 'number';\n            offsetMode.bottom = typeof this.nzOffsetBottom === 'number';\n        }\n        const targetRect = getTargetRect(targetNode);\n        const targetInnerHeight = targetNode.innerHeight || targetNode.clientHeight;\n        if (scrollTop >= elemOffset.top - offsetTop && offsetMode.top) {\n            const width = elemOffset.width;\n            const top = targetRect.top + offsetTop;\n            this.setAffixStyle(e, {\n                position: 'fixed',\n                top,\n                left: targetRect.left + elemOffset.left,\n                width\n            });\n            this.setPlaceholderStyle({\n                width,\n                height: elemSize.height\n            });\n        }\n        else if (scrollTop <= elemOffset.top + elemSize.height + this.nzOffsetBottom - targetInnerHeight &&\n            offsetMode.bottom) {\n            const targetBottomOffset = targetNode === window ? 0 : window.innerHeight - targetRect.bottom;\n            const width = elemOffset.width;\n            this.setAffixStyle(e, {\n                position: 'fixed',\n                bottom: targetBottomOffset + this.nzOffsetBottom,\n                left: targetRect.left + elemOffset.left,\n                width\n            });\n            this.setPlaceholderStyle({\n                width,\n                height: elemOffset.height\n            });\n        }\n        else {\n            if (e.type === AffixRespondEvents.resize &&\n                this.affixStyle &&\n                this.affixStyle.position === 'fixed' &&\n                this.placeholderNode.offsetWidth) {\n                this.setAffixStyle(e, Object.assign(Object.assign({}, this.affixStyle), { width: this.placeholderNode.offsetWidth }));\n            }\n            else {\n                this.setAffixStyle(e);\n            }\n            this.setPlaceholderStyle();\n        }\n        if (e.type === 'resize') {\n            this.syncPlaceholderStyle(e);\n        }\n    }\n    updateRtlClass() {\n        const wrapEl = this.fixedEl.nativeElement;\n        if (this.dir === 'rtl') {\n            if (wrapEl.classList.contains(NZ_AFFIX_CLS_PREFIX)) {\n                wrapEl.classList.add(`${NZ_AFFIX_CLS_PREFIX}-rtl`);\n            }\n            else {\n                wrapEl.classList.remove(`${NZ_AFFIX_CLS_PREFIX}-rtl`);\n            }\n        }\n        else {\n            wrapEl.classList.remove(`${NZ_AFFIX_CLS_PREFIX}-rtl`);\n        }\n    }\n}\nNzAffixComponent.ɵfac = function NzAffixComponent_Factory(t) { return new (t || NzAffixComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NzConfigService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NzScrollService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Platform), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.Directionality, 8)); };\nNzAffixComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NzAffixComponent, selectors: [[\"nz-affix\"]], viewQuery: function NzAffixComponent_Query(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 7);\n    } if (rf & 2) {\n        let _t;\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.fixedEl = _t.first);\n    } }, inputs: { nzTarget: \"nzTarget\", nzOffsetTop: \"nzOffsetTop\", nzOffsetBottom: \"nzOffsetBottom\" }, outputs: { nzChange: \"nzChange\" }, exportAs: [\"nzAffix\"], features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c1, decls: 3, vars: 0, consts: [[\"fixedEl\", \"\"]], template: function NzAffixComponent_Template(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", null, 0);\n        ɵngcc0.ɵɵprojection(2);\n        ɵngcc0.ɵɵelementEnd();\n    } }, encapsulation: 2, changeDetection: 0 });\nNzAffixComponent.ctorParameters = () => [\n    { type: ElementRef },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: NzConfigService },\n    { type: NzScrollService },\n    { type: NgZone },\n    { type: Platform },\n    { type: Renderer2 },\n    { type: ChangeDetectorRef },\n    { type: Directionality, decorators: [{ type: Optional }] }\n];\nNzAffixComponent.propDecorators = {\n    fixedEl: [{ type: ViewChild, args: ['fixedEl', { static: true },] }],\n    nzTarget: [{ type: Input }],\n    nzOffsetTop: [{ type: Input }],\n    nzOffsetBottom: [{ type: Input }],\n    nzChange: [{ type: Output }]\n};\n__decorate([\n    WithConfig(),\n    InputNumber(undefined)\n], NzAffixComponent.prototype, \"nzOffsetTop\", void 0);\n__decorate([\n    WithConfig(),\n    InputNumber(undefined)\n], NzAffixComponent.prototype, \"nzOffsetBottom\", void 0);\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NzAffixComponent, [{\n        type: Component,\n        args: [{\n                selector: 'nz-affix',\n                exportAs: 'nzAffix',\n                template: `\n    <div #fixedEl>\n      <ng-content></ng-content>\n    </div>\n  `,\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                encapsulation: ViewEncapsulation.None\n            }]\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }, { type: ɵngcc1.NzConfigService }, { type: ɵngcc2.NzScrollService }, { type: ɵngcc0.NgZone }, { type: ɵngcc3.Platform }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc4.Directionality, decorators: [{\n                type: Optional\n            }] }]; }, { nzChange: [{\n            type: Output\n        }], fixedEl: [{\n            type: ViewChild,\n            args: ['fixedEl', { static: true }]\n        }], nzTarget: [{\n            type: Input\n        }], nzOffsetTop: [{\n            type: Input\n        }], nzOffsetBottom: [{\n            type: Input\n        }] }); })();\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzAffixModule {\n}\nNzAffixModule.ɵfac = function NzAffixModule_Factory(t) { return new (t || NzAffixModule)(); };\nNzAffixModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NzAffixModule });\nNzAffixModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[BidiModule, CommonModule, PlatformModule]] });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NzAffixModule, [{\n        type: NgModule,\n        args: [{\n                declarations: [NzAffixComponent],\n                exports: [NzAffixComponent],\n                imports: [BidiModule, CommonModule, PlatformModule]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NzAffixModule, { declarations: function () { return [NzAffixComponent]; }, imports: function () { return [BidiModule, CommonModule, PlatformModule]; }, exports: function () { return [NzAffixComponent]; } }); })();\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NzAffixComponent, NzAffixModule };\n\n//# sourceMappingURL=ng-zorro-antd-affix.js.map"],"sourceRoot":"webpack:///"}